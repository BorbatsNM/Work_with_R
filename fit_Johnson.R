# =============================================================================
# 
# Функция для подбора кривой из системы Джонсона [1] методом процентилей [2] 
# и методом максимального правдоподобия - наименьших квадратов (MLE-LS) [3]
# по эмпирическим данным.
# Аргументами функции являются:
#        x - числовой вектор выборочных данных;
#   method - строка символов, указывающая метод оценки параметров подбираемой
#            кривой, по умолчанию установлено значение "MLE-LS", второе
#            допустимое значение - "percentile", в этом случае возвращаются
#            значения параметров, найденные методом процентилей;
#        z - исходное значение квантиля стандартного нормального 
#            распределения, используемое при оценке параметров подбираемой 
#            кривой, по умолчанию используется значение 0.5. На основе 
#            заданного исходного значения определяются остальные три квантиля
#            так, что они оказываются равноудалёнными друг от друга, а именно:
#            (-3z, -z, z, 3z), при этом их среднее равно нулю. Если при
#            использовании метода процентилей требуется обеспечить лучшую
#            аппроксимацию к данным на одном хвосте распределения лучше, чем
#            на другом, то в качестве аргумента z можно задать вектор из 
#            четырёх равноудалённых значений, которые соответствуют квантилям
#            стандартного нормального распределения, среднее которых не равно
#            нулю, например, чтобы обеспечить лучшее соответствие подбираемой
#            кривой на правом хвосте распределения данных, чем на левом, 
#            аргумент z можно задать в виде вектора (-0.5, 0.25, 1.0, 1.75);
#    alpha - значения порядка квантиля стандартного нормального распределения,
#            соответствующего значению -3z в методе процентилей (значению 
#            z = 0.5 соответствует значение alpha примерно равное 0.067). 
#            Следует учитывать, что так как между параметрами alpha и z 
#            существует взаимосвязь, то при задании одного параметра, второй
#            игнорируется, при этом если z - скаляр, то при заданном параметре
#            alpha, значение z игнорируется, если же z - четырёхэлементный
#            вектор, то игнорируется параметр alpha в случае его задания;
#      msp - метод для определения семейства кривых и начальных значений оценок
#            параметров, доступными значениями являются "percentile" - для метода
#            процентилей, "quant" - для метода квантилей и "moment" - для метода
#            моментов, следует учитывать, что значения данного аргумента, 
#            имеют смысл только если для аргумента method заданно значение "MLE-LS",
#            однако, при method = "percentile" все значения аргумента msp кроме
#            "percentile" игнорируются с предупреждением; 
#        p - значение или вектор значений уровней квантилей подобранной
#            кривой из семейства Джонсона, которые необходимо вернуть;
#     iter - число итераций, выполняемых при оценке параметров подбираемой
#            кривой методом MLE-LS. Если процесс оценки не завершается
#            успехом до выполнения указанного числа итераций, возвращаются 
#            наилучшие из найденных оценок, с предупреждением;
#      tol - допустимая ошибка сравнения при выборе семейства кривых методом
#            процентилей, по умолчанию установлено значение 1e-4;
#     plot - логический аргумент, указывающий необходимо ли выполнять 
#            графическое сопоставление распределения выборочных данных 
#            с подобранным распределением из системы Джонсона. 
#            Если установлено значение TRUE, то в графическое устройство 
#            выводится гистограмма с наложенной на неё графиком функции
#            плотности подобранной кривой и графики эмпирической и теоретической
#            кумулятивных функций (cdf).
# chi2test - логический аргумент, указывающий нужно ли проводить оценку
#            качества подбора по критерию согласия хи-квадрат Пирсона.
#            
# Общий синтаксис функции:
# 
#     fit_Johnson(x, na.rm = FALSE, method = "MLE-LS", z = 0.5,
#                 alpha = NULL, p = NULL, iter = 1000, tol = 1e-4,
#                 plot = FALSE, chi2test = FALSE)
#
#
#  Литература:
#   [1] Johnson, N.L. (1949) Systems of Frequency Curves Generated by
#       Methods of Translation, Biometrika, Vol. 36, No. 1/2, pp. 149-176.
#   [2] Slifker, J.F. and Shapiro, S.S. (1980) The Johnson System: Selection
#       and Parameter Estimation, Technometrics, Vol. 22, No. 2, pp. 239-246.
#   [3] George, F. and Ramachandran, K.M. (2011) Estimation of Parameters
#       of Johnson's System of Distributions, Journal of Modern Applied
#       Statistical Methods, Vol. 10, No. 2, pp. 494-504.
#
# =============================================================================
# Создан: ФГБОУ ВО "Брянский государственный технический университет"
# Авторы: Н.М. Борбаць, Т.В. Школина
# E-mail: borbact@mail.ru; shkolina.tv@yandex.ru
# =============================================================================

# необходимые пакеты
library(ggplot2)
library(SuppDists)


fit_Johnson <- function(x, msp = "percentile", method = "MLE-LS",
                        z = 0.5, alpha = NULL, tol = 1e-4, iter = 100,
                        p = NULL, plot = FALSE, chi2test = FALSE) {
  
  # проверка входных аргументов
  stopifnot(is.vector(x), is.numeric(x), is.numeric(z), is.vector(z), 
            is.numeric(tol), is.numeric(iter), tol <= 0.1, iter > 0,
            length(tol) == 1, length(iter) == 1)
  stopifnot(is.logical(plot), length(method) == 1, length(plot) == 1,
            is.logical(chi2test), length(chi2test) == 1, length(msp) == 1)
  stopifnot(is.character(method), method %in% c("MLE-LS", "percentile"))
  stopifnot(is.character(msp), msp %in% c("percentile", "quant", "moment"))
  if (!is.null(alpha)) {
    stopifnot(is.numeric(alpha), length(alpha) == 1, 
              alpha > 0, alpha < 0.5)
  }
  if (!is.null(p)) {
    stopifnot(is.numeric(p), is.vector(p), all((p > 0) & (p < 1)))
  }
  if (length(z) > 1) {
    if (length(z) != 4) {
      stop("Вектор z должен состоять из четырёх равноудалённых элементов.")
    } else if (!all(diff(z) > 0)) {
        stop("Вектор z должен содержать монотонно возрастающие значения.")
    } else {
      diffz <- diff(z)
      Rz <- range(diffz)[2] - range(diffz)[1]
      if (!isTRUE(all.equal(Rz, 0))) {
        stop("Все элементы вектора z должны быть равноудалёнными.")
      }
    }
  }
  if (chi2test & length(x) < 50) {
    stop("Недостаточный объём выборки для выполнения хи-квадрат теста.")
  }
  if (method == "percentile" & msp != "percentile") {
    msp <-  "percentile"
    message("Значение аргумента 'msp' не используется.")
  }
  if (msp != "percentile" & !is.null(alpha)) {
    message("Значение аргумента 'alpha' не используется.")
  }
  if (msp != "percentile" & length(z) > 1) {
     message("Значение аргумента 'z' не используется.")
  }
  if (length(z) == 1) {
     if (msp != "percentile" & z != 0.5) {
       message("Значение аргумента 'z' не используется.")
   }
  }

  
  ### Вспомогательные функции ####
  
  # функция оценки параметров подбираемой кривой в системе Джонсона
  # с использованием метода процентилей
  est_percentile <- function(m, n, pp, q0, z0, dz, type) {
    switch(type,
           SB = {pm <- pp/m; pn <- pp/n
                 eta <- dz/acosh(0.5*sqrt((1 + pm)*(1 + pn)))
                 gamma <- z0 + eta*asinh((pn - pm)*sqrt((1 + pm)*(1 + pn) - 4)/
                                           (2*(pm*pn - 1)))
                 lambda <- pp*sqrt(((1 + pm)*(1 + pn) - 2)^2 - 4)/(pm*pn - 1)
                 epsilon <- q0 - 0.5*lambda + pp*(pn - pm)/(2*(pm*pn - 1))},
           SU = {mp <- m/pp; np <- n/pp
                 eta <- 2*dz/acosh(0.5*(mp + np))
                 gamma <- z0 + eta*asinh((np - mp)/(2*sqrt(mp*np - 1)))
                 lambda <- 2*pp*sqrt(mp*np - 1)/((mp + np - 2)*sqrt(mp + np + 2))
                 epsilon <- q0 + pp*(np - mp)/(2*(mp + np - 2))},
           SL = {mp <- m/pp
                 eta <- 2*dz/log(mp)
                 gamma <- z0 + eta*log(abs(mp - 1)/(pp*sqrt(mp)))
                 lambda <- sign(mp - 1)
                 epsilon <- q0 - 0.5*pp*(mp + 1)/(mp - 1)},
           SN = {eta <- 2*dz/m
                 gamma <- z0 - q0*eta
                 lambda <- 1
                 epsilon <- 0})
    
    estimates <- c(eta = eta, gamma = gamma, 
                   lambda = lambda, epsilon = epsilon)
    
    return(estimates)
  }
  
  # вспомогательная функция для определения эмпирических квантилей и квантилей
  # стандартного нормального распределения, используемых при оценке параметров
  # подбираемой кривой методом "MLE-LS"
  get_quantiles <- function(x) {
    n <- length(x)
    if (n < 100) {
      probs <- ((1:(n - 1)) - 0.5)/n
      x <- x[1:(n - 1)]
      zp <- qnorm(probs)
    } else {
      probs <- (1:99)/100
      x <- quantile(x, probs, type = 5, names = FALSE)
      zp <- qnorm(probs)
    }
    dt <- data.frame(x = x, zp = zp)
    return(dt)
  }
  
  # функция оценки параметров подбираемой кривой в системе Джонсона
  # с использованием метода "MLE-LS"
  est_MLESL <- function(dt, inparms, type) {
    y <- (dt$x - inparms[4])/inparms[3]
    switch(type,
           SB = {gy <- log(y/(1 - y))
                 n <- length(gy) - sum(is.na(gy))
                 eta <- sqrt(1/(var(gy, na.rm = TRUE)*(n - 1)/n))
                 gamma <- -eta*mean(gy, na.rm = TRUE)
                 u <- 1/(1 + exp((gamma - dt$zp)/eta))
                 fit <- lm(dt$x ~ u)
                 epsilon <- coef(fit)[[1]]
                 lambda <- coef(fit)[[2]]
                 RSS <- sum(residuals(fit)^2)
                 estimates <- c(eta = eta, gamma = gamma, 
                                lambda = lambda, epsilon = epsilon)},
           SU = {gy <- asinh(y)
                 n <- length(gy) - sum(is.na(gy))
                 eta <- sqrt(1/(var(gy, na.rm = TRUE)*(n - 1)/n))
                 gamma <- -eta*mean(gy, na.rm = TRUE)
                 u <- sinh((dt$zp - gamma)/eta)
                 fit <- lm(dt$x ~ u)
                 epsilon <- coef(fit)[[1]]
                 lambda <- coef(fit)[[2]]
                 RSS <- sum(residuals(fit)^2)
                 estimates <- c(eta = eta, gamma = gamma, 
                                lambda = lambda, epsilon = epsilon)},
           SL = {gy <- log(y)
                 n <- length(gy) - sum(is.na(gy))
                 eta <- sqrt(1/(var(gy, na.rm = TRUE)*(n - 1)/n))
                 gamma <- -eta*mean(gy, na.rm = TRUE)
                 u <- exp((dt$zp - gamma)/eta)
                 lambda <- inparms[[3]]
                 epsilon <- mean(dt$x) - mean(u)
                 RSS <- sum((dt$x - (epsilon + u))^2)
                 estimates <- c(eta = eta, gamma = gamma, 
                                lambda = lambda, epsilon = epsilon)},
           SN = {n <- length(y) - sum(is.na(y))
                 eta <- sqrt(1/(var(y, na.rm = TRUE)*(n - 1)/n))
                 gamma <- -eta*mean(y, na.rm = TRUE)
                 u <- (dt$zp - gamma)/eta
                 lambda <- inparms[[3]]
                 epsilon <- inparms[[4]]
                 RSS <- sum((dt$x - u)^2)
                 estimates <- c(eta = eta, gamma = gamma, 
                                lambda = lambda, epsilon = epsilon)})
    result <- list(RSS = RSS, estimates = estimates)
    return(result)
  }
  
  # вспомогательная функция для выполнения проверки качества подбора
  # по критерию согласия хи-квадрат
  make_chisqtest <- function(obs, U_edges, parms, k) {
    fit_cdf <- pJohnson(U_edges, parms)
    p_expt <- c(fit_cdf[1], diff(fit_cdf))
    p_expt[length(p_expt) + 1] <- 1 - fit_cdf[length(fit_cdf)]
    expt <- sum(obs)*p_expt
    if (any(expt < 5)) {
      # вначале объединяем все внешние интервалы с ожидаемой частотой меньше пяти
      index_1 <- which(expt < 5)
      index_2 <- which(expt >= 5)
      obs <- c(sum(obs[index_1[index_1 < min(index_2)]]),
               obs[min(index_2):max(index_2)],
               sum(obs[index_1[index_1 > max(index_2)]]))
      expt <- c(sum(expt[index_1[index_1 < min(index_2)]]),
                expt[min(index_2):max(index_2)],
                sum(expt[index_1[index_1 > max(index_2)]]))
      # проверяем - остались ли внешние интервалы с ожидаемой частотой меньше пяти, 
      # если остались, объединяем их с соседними интервалами
      if (expt[1] < 5) {
        obs <- c(obs[1] + obs[2], obs[3:length(obs)])
        expt <- c(expt[1] + expt[2], expt[3:length(expt)])
      }
      if (expt[length(expt)] < 5) {
        obs <- c(obs[1:(length(obs) - 2)], 
                 obs[length(obs) - 1] + obs[length(obs)])
        expt <- c(expt[1:(length(expt) - 2)], 
                  expt[length(expt) - 1] + expt[length(expt)])
      }
    }
    p_expt <- expt/sum(expt)
    result <- chisq.test(obs, p = p_expt)
    result$data.name <- "Observed Frequencies"
    # корректировка результатов расчёта критерия хи-квадрат
    if (result$parameter - k > 0) {
      result$parameter <- result$parameter - k
      result$p.value <- pchisq(result$statistic, result$parameter, 
                               lower.tail = FALSE)
    } else {
      result$parameter <- NA
      result$p.value <- NA
      warning("Недостаточно числа степеней свободы для выполнения проверки.",
              call. = FALSE) 
    }
    return(result)
  }
  
  # вспомогательная функция для представления результатов оценки в виде,
  # пригодном для вызова функций пакета SuppDists
  get_parms_SuppDists <- function(Results) {
    parms <- list(gamma = Results$coefficients[[2]],
                  delta = Results$coefficients[[1]],
                  xi = Results$coefficients[[4]],
                  lambda = Results$coefficients[[3]],
                  type = Results$type)
    return(parms)
  }
  
  
  #### Основная часть ####
  
  x <- sort(x)
  # определение семейства кривых и нахождение начальных значений
  if (msp == "percentile") { # методом процентилей
    if (is.null(alpha) & (length(z) == 1)) {
      z0 <- 0 
      dz <- z
      z <- c(-3*z, -z, z, 3*z)
    } else if (!is.null(alpha) & (length(z) == 1)) {
      if (z != 0.5) {
        message("Значение аргумента 'z' не используется.")
      }
      z <- qnorm(alpha)
      z <- c(z, z/3, -z/3, -z)
      z0 <- mean(z) 
      dz <- 0.5*mean(diff(z))
    } else {
      if (!is.null(alpha)) {
        message("Значение аргумента 'alpha' не используется.")
      }
      z0 <- mean(z); 
      dz <- 0.5*mean(diff(z))
    }
    probs <- pnorm(z)
    quantiles <- quantile(x, probs, type = 5, names = FALSE)
    m <- quantiles[4] - quantiles[3]
    n <- quantiles[2] - quantiles[1]
    pp <- quantiles[3] - quantiles[2]
    q0 <- 0.5*sum(quantiles[2:3])
    mp <- m/pp; np <- n/pp
    if (mp*np < 1 - tol) {
      type <- "SB"
    } else if (mp*np > 1 + tol) {
      type <- "SU"
    } else {
      if (abs(mp - 1) > tol) {
        type <- "SL"
      } else {
        type <- "SN"
      }
    }
    Results <- list(type = type)
    Results$coefficients <- est_percentile(m, n, pp, q0, z0, dz, type)
  } else if (msp == "quant") { # методом квантилей с помощью "SuppDists"
    fit <- JohnsonFit(x)
    Results <- list(type = fit$type)
    Results$coefficients <- c(eta = fit$delta, gamma = fit$gamma,
                              lambda = fit$lambda, epsilon = fit$xi)
  } else { # методом моментов с помощью "SuppDists"
    fit <- JohnsonFit(x, moment = "find")
    Results <- list(type = fit$type)
    Results$coefficients <- c(eta = fit$delta, gamma = fit$gamma,
                              lambda = fit$lambda, epsilon = fit$xi)
  }
  
  # в зависимости от заданного значения аргумента method вектор "estimates"
  # записываются в список результатов, либо используются в качестве
  # начальных значений в методе "MLE-LS"
  if (method == "percentile") {
    Results$RSS <- NA
    Results$method <- "Percentile Matching"
  } else {
    quantiles <- get_quantiles(x)
    # первая итерация
    temp <- est_MLESL(quantiles, Results$coefficients, Results$type)
    estm1 <- temp$estimates
    RSS1 <- temp$RSS
    # вторая интерация
    temp <- est_MLESL(quantiles, estm1, Results$type)
    estm2 <- temp$estimates
    RSS2 <- temp$RSS
    # если RSS1 <= RSS2, то наилучшие оценки найдены на первой итерации
    if (RSS1 <= RSS2) {
      result <- list(RSS = RSS1, estimates = estm1)
    } else {
      count <- 2 # две итерации уже выполненны
      while ((RSS1 > RSS2) & (count <= iter)) {
        RSS1 <- RSS2; estm1 <- estm2
        temp <- est_MLESL(quantiles, estm1, Results$type)
        estm2 <- temp$estimates
        RSS2 <- temp$RSS
        count <- count + 1
        result <- list(RSS = RSS1, estimates = estm1)
        if (count == iter) {
          warning(paste("Достигнуто предельное число итераций. В качестве оценок",
                        "возвращаются значения\n с наименьшей из всех остаточной",
                        "суммой квадратов."), call. = FALSE)
          result <- list(RSS = RSS2, estimates = estm2)
        }
      }
    }
    Results$coefficients <- result$estimates
    Results$RSS <- result$RSS
    Results$method <- "MLE-Least Square Approach"
  }
  
  # Так как кривые семейств SB и SL содержат параметры, соответствующие 
  # границам области возможных значений случайной величины, то целесообразно
  # сравнить полученные оценки этих параметров с результатами наблюдений
  if (Results$type == "SB" & 
      (Results$coefficients[[4]] > min(x) |
      (Results$coefficients[[3]] + Results$coefficients[[4]]) < max(x))) {
    warning(paste("Оценки границ области возможных значений не соответствуют",
                  "результатам наблюдений.\n  Подбор кривой может быть",
                  "неудовлетворительным."))
  }
  if (Results$type == "SL" & Results$coefficients[[4]] > min(x)) {
    warning(paste("Оценка границы области возможных значений не соответствует",
                  "результатам наблюдений.\n  Подбор кривой может быть",
                  "неудовлетворительным."))
  }
  
  
  # Проверка качества подбора по критерию согласия хи-квадрат (если число
  # наблюдений не меньше 50-ти) и построение графиков, если требуется
  if (chi2test | plot) {
    nbins <- max(5, floor(sqrt(length(x))))
    group_res <- ggplot(data = data.frame(x)) + 
      stat_bin(aes(x), bins = nbins)
    group_res <- ggplot_build(group_res)
    # наблюдаемые частоты
    obs <- group_res$data[[1]]$count
    # верхние границы интервалов
    U_edges <- group_res$data[[1]]$xmax
    U_edges <- U_edges[-length(U_edges)]
    # список параметров для расчёта pdf и cdf подобранной кривой
    # с использованием функций пакета SuppDists
    parms <- get_parms_SuppDists(Results)
    # проверка по критерию согласия хи-квадрат
    if (length(x) >= 50 & chi2test) {
      # определение числа ограничений
      k <- ifelse(Results$type == "SN", 2, ifelse(Results$type == "SL", 3, 4))
      print(make_chisqtest(obs, U_edges, parms, k))
    }
    
    # построение графиков
    if (plot) {
      # гистограмма с кривой pdf
      ymin <- group_res$data[[1]]$xmin[[1]]
      ymax <- group_res$data[[1]]$xmax[[length(obs)]]
      y <- seq(ymin, ymax, length = 1000)
      fit_pdf <- dJohnson(y, parms)*sum(obs)*diff(U_edges)[[1]]
      figure1 <- ggplot(data = data.frame(x)) + 
        geom_histogram(aes(x), bins = nbins, fill = "dodgerblue3",
                       color = "white") + 
        geom_line(data = na.omit(data.frame(y, fit_pdf)),
                  aes(y, fit_pdf), color = "red", linewidth = 1.2) +
        theme_classic() + labs(title = "Гистограмма с подобранной кривой",
                               x = "Результаты наблюдений",
                               y = "Частота") + 
        theme(plot.title = element_text(hjust = 0.5))
      
      # эмпирическая функция распределения с кривой cdf
      ymin <- min(x); ymax <- max(x)
      y <- seq(ymin, ymax, length = 1000)
      fit_cdf <- pJohnson(y, parms)
      figure2 <- ggplot(data = data.frame(x)) + geom_step(aes(x), stat = "ecdf",
                                                          linewidth = 0.75) +
        geom_line(data = na.omit(data.frame(y, fit_cdf)), aes(y, fit_cdf),
                  color = "red", linewidth = 0.75) + theme_bw() + 
        labs(title = "Кривые эмпирической и подобранной функции распределения", 
             x = "Результаты наблюдений, x", y = "F(x)") +
        theme(plot.title = element_text(hjust = 0.5))
      
      # вывод графиков на графическое устройство
      plot(figure1); plot(figure2)
    }
  }
  
  # нахождение процентилей подобранного распределения Джонсона, если требуется
  if (!is.null(p)) {
    parms <- get_parms_SuppDists(Results)
    fit_percentiles <- qJohnson(p, parms)
    names(fit_percentiles) <- paste0(p*100, "%")
    Results$percentiles <- fit_percentiles
  } else {
    Results$percentiles <- NA
  }
  
  return(Results)
  
}